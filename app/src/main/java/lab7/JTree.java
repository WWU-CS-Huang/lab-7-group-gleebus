/*
 * Author: Fabien Gardes-Picado & Tyler Eads
 * Date: 2025-06-03
 * Purpose: Lab 7
 * Generated by gradle init function
 */

package lab7;
import java.util.HashMap;

// JTree is used to construct our code tree, with entries and other JTrees linked together 
public class JTree {
    public Entry root;
    public HashMap<Character, String> map = new HashMap<Character, String>();

    class Entry {
        public Character value;
        public int frequency;
        public Entry leftChild;
        public Entry rightChild;
        public Entry parent;

        Entry(Character v, int f) {
            value = v;
            frequency = f;
        }

        Entry(Character v, int f, Entry left, Entry right) {
            value = v;
            frequency = f;
            leftChild = left;
            rightChild = right;
        }

        public String toString() {
            return (value.toString() + " " + frequency);
        }
    }

    public JTree(Character v, int f) {
        Entry j = new Entry(v, f);
        root = j;
        j.parent = null;
    }

    public JTree(Entry left, Entry right) {
        int combinedFreq = left.frequency + right.frequency;
        Entry j = new Entry(null, combinedFreq, left, right);
        left.parent = j;
        right.parent = j;
        root = j;
        j.parent = null;
    }

    public int getTreeFreq() {
        return root.frequency;
    }

    // give it a bitstring, it spits out the encoding
    // if you give anything other than 0 or 1, it spits out "invalid input"
    public String decode(String bitstring) {
        String retString = "";
        Entry currentNode = root;

        while (!(bitstring.equals(""))) {
            // go left
            if (bitstring.charAt(0) == '0') {
                currentNode = currentNode.leftChild;

                // if we have a non-null value, we've reached the leaf
                if (currentNode.value != null) {
                    retString += currentNode.value;
                    currentNode = root;
                }

            // go right
            } else if (bitstring.charAt(0) == '1') {
                currentNode = currentNode.rightChild;

                // if we have a non-null value, we've reached the leaf
                if (currentNode.value != null) {
                    retString += currentNode.value;
                    currentNode = root;
                }

            } else {
                //invalid input
                return "Invalid Input - Encountered non-binary bit " + bitstring.charAt(0);
            }

            bitstring = bitstring.substring(1);
        }
        return retString;
    }    

    public String encode(String input) {
        String retVal = "";

        while (input.length() > 0) {
            Character temp = input.charAt(0);
            if (!(map.containsKey(temp))) {
                return ("String cannot be encoded because character " + temp.toString() + " is not in tree");
            }
            String bits = map.get(temp);
            retVal += bits;
            input = input.substring(1);
        }

        return retVal;
    }


    // build the hash map that gives bitstrings when given characters
    public void buildMap() {
        recurseMap(root, "");
    }

    // recursive function of building the map
    public void recurseMap(Entry e, String s) {
        if (e.value != null) {
            map.put(e.value, s);
            return;
        }

        recurseMap(e.leftChild, (s + "0"));
        recurseMap(e.rightChild, (s + "1"));
    }
}
